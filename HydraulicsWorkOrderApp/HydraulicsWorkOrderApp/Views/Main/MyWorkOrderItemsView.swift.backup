//
//  MyWorkOrderItemsView.swift
//  HydraulicsWorkOrderApp
//
//  Created by Bec Archer on 9/2/25.
//

// ───── MY WORK ORDER ITEMS VIEW ─────
import SwiftUI
import Combine

/// Shows WO_Items for the currently logged-in user, filtered by status (excluding "Checked In")
/// Filters: statusHistory.status != "Checked In" && statusHistory.user == currentUser.displayName
struct MyWorkOrderItemsView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var workOrdersDB = WorkOrdersDatabase.shared
    @State private var filteredItemData: [WorkOrderItemData] = []
    @State private var isLoading = true
    @State private var selectedItemForSheet: WorkOrderItemData?

    var body: some View {
        // ───── BODY ─────
        ScrollView {
            LazyVStack(spacing: 16) {
                if isLoading {
                    ProgressView("Loading your work items...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .padding(.top, 100)
                } else if filteredItemData.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "doc.text.magnifyingglass")
                            .font(.system(size: 48))
                            .foregroundStyle(.secondary)
                        Text("No Work Items Found")
                            .font(.title2)
                            .fontWeight(.medium)
                        Text("You haven't worked on any items yet, or all items are still in 'Checked In' status.")
                            .font(.body)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .padding(.top, 100)
                } else {
                    ForEach(filteredItemData) { latestItem in
                        MyWorkOrderItemCard(
                            item: latestItem.item,
                            workOrder: latestItem.workOrder,
                            itemIndex: latestItem.itemIndex,
                            onTap: {
                                print("🔍 DEBUG: Tapped on item: \(latestItem.workOrder.workOrderNumber)-\(String(format: "%03d", latestItem.itemIndex + 1))")
                                print("🔍 DEBUG: Setting selectedItemForSheet: \(latestItem.workOrder.workOrderNumber)")
                                
                                // Set the selected item for the sheet
                                selectedItemForSheet = latestItem
                                
                                print("🔍 DEBUG: selectedItemForSheet is now: \(selectedItemForSheet?.workOrder.workOrderNumber ?? "nil")")
                            }
                        )
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
        .navigationTitle("My Work Items")
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            loadFilteredItems()
        }
        .refreshable {
            loadFilteredItems()
        }
        .fullScreenCover(item: $selectedItemForSheet) { latestItem in
            ItemDetailSheetView(
                workOrder: latestItem.workOrder,
                item: latestItem.item,
                itemIndex: latestItem.itemIndex
            ) {
                selectedItemForSheet = nil
                // Refresh the data when sheet is dismissed
                print("🔍 DEBUG: Sheet dismissed, refreshing data")
                loadFilteredItems()
            }
            .environmentObject(appState)
        }
        // END
    }

    // MARK: - Private Methods

    private func loadFilteredItems() {
        print("🔍 DEBUG: loadFilteredItems called")
        isLoading = true
        
        Task {
            do {
                // Fetch all work orders from database
                let allWorkOrders = try await workOrdersDB.getAllWorkOrders()
                print("🔍 DEBUG: Retrieved \(allWorkOrders.count) work orders from database")
                
                // Filter to active work orders only
                let activeWorkOrders = allWorkOrders.filter { workOrder in
                    !workOrder.isDeleted && workOrder.status.lowercased() != "closed"
                }
                
                // Extract items where current user has made status/note updates (excluding "Checked In")
                var latestItemArray: [WorkOrderItemData] = []
                
                for workOrder in activeWorkOrders {
                    for (itemIndex, item) in workOrder.items.enumerated() {
                        // Check if this item has status history from current user (excluding "Checked In")
                        let userStatusUpdates = item.statusHistory.filter { status in
                            status.user == appState.currentUserName && 
                            status.status.lowercased() != "checked in"
                        }
                        
                        // Check if this item has notes from current user
                        let userNotes = item.notes.filter { note in
                            note.user == appState.currentUserName
                        }
                        
                        // Include if user has made any status updates or notes
                        if !userStatusUpdates.isEmpty || !userNotes.isEmpty {
                            print("🔍 DEBUG: Found item for user - WO: \(workOrder.workOrderNumber), Item: \(itemIndex), Status: \(item.statusHistory.last?.status ?? "none")")
                            latestItemArray.append(WorkOrderItemData(
                                item: item,
                                workOrder: workOrder,
                                itemIndex: itemIndex
                            ))
                        }
                    }
                }
                
                // Sort by most recent activity (status updates or notes)
                latestItemArray.sort { data1, data2 in
                    let latest1 = getLatestActivityTimestamp(for: data1.item)
                    let latest2 = getLatestActivityTimestamp(for: data2.item)
                    return latest1 > latest2
                }
                
                await MainActor.run {
                    self.filteredItemData = latestItemArray
                    self.isLoading = false
                }
                
            } catch {
                print("❌ Error loading work orders: \(error)")
                await MainActor.run {
                    self.isLoading = false
                }
            }
        }
    }
    
    private func getLatestActivityTimestamp(for item: WO_Item) -> Date {
        var latestDate = Date.distantPast
        
        // Check latest status update
        for status in item.statusHistory {
            if status.timestamp > latestDate {
                latestDate = status.timestamp
            }
        }
        
        // Check latest note
        for note in item.notes {
            if note.timestamp > latestDate {
                latestDate = note.timestamp
            }
        }
        
        return latestDate
    }
}

// MARK: - Data Structure
struct WorkOrderItemData: Identifiable {
    let id = UUID()
    let item: WO_Item
    let workOrder: WorkOrder
    let itemIndex: Int
}

// MARK: - Custom Item Card for My Work Orders
struct MyWorkOrderItemCard: View {
    let item: WO_Item
    let workOrder: WorkOrder
    let itemIndex: Int
    let onTap: () -> Void
    
    @State private var partsUsedText: String = ""
    @State private var isEditingParts: Bool = false
    @State private var isSavingParts: Bool = false
    @StateObject private var workOrdersDB = WorkOrdersDatabase.shared
    
    // Get current status from statusHistory
    private var currentStatus: String {
        item.statusHistory.last?.status ?? "Unknown"
    }
    
    // Get most recent note text for display
    private var recentNoteText: String {
        item.notes.last?.text ?? ""
    }
    
    var body: some View {
        Button(action: onTap) {
            VStack(alignment: .leading, spacing: 12) {
                // ───── Header Row ─────
                HStack {
                    // Work Order Number
                    Text("\(workOrder.workOrderNumber)-\(String(format: "%03d", itemIndex + 1))")
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Spacer()
                    
                    // Status Badge
                    StatusBadge(status: currentStatus)
                }
                
                // ───── Item Type and Details ─────
                VStack(alignment: .leading, spacing: 6) {
                    Text(item.type)
                        .font(.title3)
                        .fontWeight(.medium)
                        .foregroundColor(.primary)
                    
                    // Show dropdown details if available
                    if !item.dropdowns.isEmpty {
                        ForEach(Array(item.dropdowns.keys.sorted()), id: \.self) { key in
                            if let value = item.dropdowns[key], !value.isEmpty {
                                HStack {
                                    Text("\(key):")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                    Text(value)
                                        .font(.caption)
                                        .foregroundColor(.primary)
                                    Spacer()
                                }
                            }
                        }
                    }
                }
                
                // ───── Customer Info (Tappable) ─────
                HStack {
                    VStack(alignment: .leading, spacing: 2) {
                        Text(workOrder.customerName)
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.primary)
                        
                        if !workOrder.customerPhone.isEmpty {
                            Text(workOrder.customerPhone)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    
                    Spacer()
                    
                    // Phone action button
                    if !workOrder.customerPhone.isEmpty {
                        Button(action: {
                            if let url = URL(string: "tel:\(workOrder.customerPhone)") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            Image(systemName: "phone")
                                .font(.subheadline)
                                .foregroundColor(.blue)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.vertical, 4)
                .padding(.horizontal, 8)
                .background(Color(.systemGray6))
                .cornerRadius(8)
                
                // ───── Reasons for Service ─────
                if !item.reasonsForService.isEmpty {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Reasons for Service:")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.secondary)
                        
                        ForEach(item.reasonsForService, id: \.self) { reason in
                            HStack(spacing: 8) {
                                Image(systemName: item.completedReasons.contains(reason) ? "checkmark.square.fill" : "square")
                                    .foregroundColor(item.completedReasons.contains(reason) ? .green : .secondary)
                                    .font(.caption)
                                
                                // ───── Display reason with note for "Other" ─────
                                if reason.lowercased().contains("other") && !(item.reasonNotes?.isEmpty ?? true) {
                                    Text("\(reason) • \(item.reasonNotes ?? "")")
                                        .font(.caption)
                                        .foregroundColor(.primary)
                                } else {
                                Text(reason)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                                }
                                
                                Spacer()
                            }
                        }
                    }
                }
                
                // ───── Recent Activity ─────
                if let lastStatus = item.statusHistory.last {
                    HStack {
                        Text("Last updated by \(lastStatus.user)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text(lastStatus.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                // ───── Recent Note ─────
                if !recentNoteText.isEmpty {
                    Text(recentNoteText)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(2)
                        .padding(.top, 4)
                }
                
                // ───── Parts Used Section ─────
                partsUsedSection
            }
            .padding(16)
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
        .buttonStyle(.plain)
        .onAppear {
            // Initialize parts used text from item
            partsUsedText = item.partsUsed ?? ""
        }
    }
    
    // MARK: - Parts Used Section
    @ViewBuilder
    private var partsUsedSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("Parts Used")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                if isEditingParts {
                    Button("Cancel") {
                        // Reset to original value and stop editing
                        partsUsedText = item.partsUsed ?? ""
                        isEditingParts = false
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)
                } else {
                    Button("Edit") {
                        isEditingParts = true
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
            
            if isEditingParts {
                VStack(spacing: 8) {
                    TextField("Enter parts used...", text: $partsUsedText, axis: .vertical)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .lineLimit(2...4)
                        .font(.caption)
                    
                    HStack {
                        Button("Save") {
                            savePartsUsed()
                        }
                        .font(.caption)
                        .foregroundColor(.blue)
                        .disabled(isSavingParts || partsUsedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                        
                        if isSavingParts {
                            ProgressView()
                                .scaleEffect(0.8)
                        }
                        
                        Spacer()
                    }
                }
            } else {
                if partsUsedText.isEmpty {
                    Text("No parts recorded yet")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .italic()
                } else {
                    Text(partsUsedText)
                        .font(.caption)
                        .foregroundColor(.primary)
                        .lineLimit(2)
                }
            }
        }
        .padding(.top, 8)
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
        .background(Color(.systemGray6))
        .cornerRadius(8)
    }
    
    // MARK: - Save Parts Used
    private func savePartsUsed() {
        guard !partsUsedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        isSavingParts = true
        
        Task {
            do {
                // Create a copy of the work order with updated parts used
                var updatedWorkOrder = workOrder
                updatedWorkOrder.items[itemIndex].partsUsed = partsUsedText.trimmingCharacters(in: .whitespacesAndNewlines)
                updatedWorkOrder.items[itemIndex].lastModified = Date()
                updatedWorkOrder.items[itemIndex].lastModifiedBy = AppState.shared.currentUserName
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = AppState.shared.currentUserName
                
                // Save to database
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
                
                await MainActor.run {
                    isEditingParts = false
                    isSavingParts = false
                }
                
            } catch {
                print("❌ Error saving parts used: \(error)")
                await MainActor.run {
                    isSavingParts = false
                }
            }
        }
    }
}

// MARK: - ItemDetailSheet
struct ItemDetailSheet: View {
    let workOrder: WorkOrder
    let item: WO_Item
    let itemIndex: Int
    
    @EnvironmentObject private var appState: AppState
    @Environment(\.dismiss) private var dismiss
    @StateObject private var workOrdersDB = WorkOrdersDatabase.shared
    
    // ───── State for functionality ─────
    @State private var showStatusSelection = false
    @State private var showAddNotes = false
    @State private var showGallery = false
    @State private var showImageViewer = false
    @State private var selectedImageURL: URL?
    
    // ───── Computed Properties ─────
    private var itemDisplayName: String {
        "\(workOrder.workOrderNumber)-\(String(format: "%03d", itemIndex + 1))"
    }
    
    private var currentStatus: String {
        item.statusHistory.last?.status ?? "Checked In"
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // ───── Custom Navigation Header ─────
            HStack {
                Button("Back") {
                    dismiss()
                }
                .foregroundColor(.blue)
                
                Spacer()
                
                Text("Item Details")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Menu {
                    Button("Change Status") {
                        showStatusSelection = true
                    }
                    
                    Button("Add Notes") {
                        showAddNotes = true
                    }
                    
                    Button("View Full Work Order") {
                        dismiss()
                        appState.navigateToWorkOrderDetail(workOrder)
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                        .foregroundColor(.blue)
                }
            }
            .padding()
            .background(Color(.systemBackground))
            
            Divider()
            
            // ───── Content ─────
            ScrollView {
                VStack(spacing: 20) {
                    // ───── Item Header Card ─────
                    itemHeaderCard
                    
                    // ───── Item Images Section ─────
                    itemImagesSection
                    
                    // ───── Item Details Section ─────
                    itemDetailsSection
                    
                    // ───── Status & Notes Section ─────
                    statusAndNotesSection
                }
                .padding()
            }
        }
        .sheet(isPresented: $showStatusSelection) {
            StatusSelectionView(
                currentStatus: currentStatus,
                onStatusSelected: { newStatus in
                    Task {
                        await updateItemStatus(newStatus)
                    }
                    showStatusSelection = false
                }
            )
        }
        .sheet(isPresented: $showAddNotes) {
            AddNotesView(
                workOrder: workOrder,
                item: item,
                itemIndex: itemIndex,
                onNotesAdded: { noteText, images in
                    Task {
                        await addItemNote(noteText, images: images)
                    }
                    showAddNotes = false
                }
            )
        }
        .sheet(isPresented: $showGallery) {
            ImageGalleryView(images: item.imageUrls, title: itemDisplayName)
        }
        .sheet(isPresented: $showImageViewer) {
            if let imageURL = selectedImageURL {
                FullScreenImageViewer(imageURL: imageURL, isPresented: $showImageViewer)
            }
        }
    }
    
    // MARK: - View Components
    
    @ViewBuilder
    private var itemHeaderCard: some View {
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text(itemDisplayName)
                                .font(.title2)
                                .fontWeight(.bold)
                            
                            Spacer()
                            
                            StatusBadge(status: currentStatus)
                        }
                        
                        Text(item.type)
                            .font(.title3)
                            .foregroundColor(.secondary)
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
    }
    
    @ViewBuilder
    private var itemImagesSection: some View {
        if !item.imageUrls.isEmpty {
            VStack(alignment: .leading, spacing: 12) {
                Text("Images")
                    .font(.headline)
                
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: 8) {
                    ForEach(Array(item.imageUrls.prefix(6).enumerated()), id: \.offset) { index, imageURL in
                        AsyncImage(url: URL(string: imageURL)) { image in
                            image
                                .resizable()
                                .scaledToFill()
                                .frame(height: 80)
                                .clipped()
                                .cornerRadius(8)
                                .onTapGesture {
                                    selectedImageURL = URL(string: imageURL)
                                    showImageViewer = true
                                }
                        } placeholder: {
                            Rectangle()
                                .fill(Color(.systemGray5))
                                .frame(height: 80)
                                .cornerRadius(8)
                        }
                    }
                }
                
                if item.imageUrls.count > 6 {
                    Button("View All Images") {
                        showGallery = true
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
    }
    
    @ViewBuilder
    private var itemDetailsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Item Details")
                .font(.headline)
                    
                    // ───── Customer Info ─────
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Customer")
                    .font(.subheadline)
                    .fontWeight(.medium)
                        
                        Text(workOrder.customerName)
                            .font(.subheadline)
                        
                        if !workOrder.customerPhone.isEmpty {
                            HStack {
                                Text(workOrder.customerPhone)
                                    .font(.subheadline)
                                
                                Spacer()
                                
                                Button(action: {
                                    if let url = URL(string: "tel:\(workOrder.customerPhone)") {
                                        UIApplication.shared.open(url)
                                    }
                                }) {
                                    Image(systemName: "phone")
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                    }
            
            // ───── Dropdown Details ─────
            if !item.dropdowns.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Specifications")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(Array(item.dropdowns.keys.sorted()), id: \.self) { key in
                        if let value = item.dropdowns[key], !value.isEmpty {
                            HStack {
                                Text("\(key):")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text(value)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                                Spacer()
                            }
                        }
                    }
                }
            }
                    
                    // ───── Reasons for Service ─────
                    if !item.reasonsForService.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Reasons for Service")
                        .font(.subheadline)
                        .fontWeight(.medium)
                            
                            ForEach(item.reasonsForService, id: \.self) { reason in
                                HStack(spacing: 8) {
                            Button(action: {
                                toggleReasonCompletion(reason)
                            }) {
                                    Image(systemName: item.completedReasons.contains(reason) ? "checkmark.square.fill" : "square")
                                        .foregroundColor(item.completedReasons.contains(reason) ? .green : .secondary)
                            }
                            
                            // ───── Display reason with note for "Other" ─────
                            if reason.lowercased().contains("other") && !(item.reasonNotes?.isEmpty ?? true) {
                                Text("\(reason) • \(item.reasonNotes ?? "")")
                                    .font(.caption)
                                    .foregroundColor(.primary)
                            } else {
                                    Text(reason)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                            }
                                    
                                    Spacer()
                        }
                    }
                                }
                            }
                        }
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
                    }
    
    @ViewBuilder
    private var statusAndNotesSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Status & Notes")
                .font(.headline)
                    
                    // ───── Status History ─────
                    if !item.statusHistory.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Status History")
                        .font(.subheadline)
                        .fontWeight(.medium)
                            
                            ForEach(item.statusHistory.reversed(), id: \.timestamp) { status in
                                HStack {
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text(status.status)
                                    .font(.caption)
                                            .fontWeight(.medium)
                                        
                                        Text("by \(status.user)")
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Text(status.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 2)
                    }
                }
            }
            
            // ───── Notes ─────
            if !item.notes.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Notes")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(item.notes.reversed(), id: \.timestamp) { note in
                        VStack(alignment: .leading, spacing: 4) {
                            Text(note.text)
                                            .font(.caption)
                                .foregroundColor(.primary)
                            
                            HStack {
                                Text("by \(note.user)")
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                                
                                Spacer()
                                
                                Text(note.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                    .font(.caption2)
                                            .foregroundColor(.secondary)
                            }
                        }
                        .padding(.vertical, 2)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
    
    // MARK: - Actions
    
    private func updateItemStatus(_ newStatus: String) async {
        do {
            var updatedWorkOrder = workOrder
            updatedWorkOrder.items[itemIndex].statusHistory.append(
                WO_Status(
                    status: newStatus,
                    user: appState.currentUserName,
                    timestamp: Date(),
                    notes: nil
                )
            )
            updatedWorkOrder.items[itemIndex].lastModified = Date()
            updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
            updatedWorkOrder.lastModified = Date()
            updatedWorkOrder.lastModifiedBy = appState.currentUserName
            
            try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
        } catch {
            print("❌ Error updating item status: \(error)")
        }
    }
    
    private func addItemNote(_ noteText: String, images: [UIImage]) async {
        do {
            var updatedWorkOrder = workOrder
            updatedWorkOrder.items[itemIndex].notes.append(
                WO_Note(
                    workOrderId: workOrder.id,
                    itemId: item.id.uuidString,
                    user: appState.currentUserName,
                    text: noteText,
                    timestamp: Date(),
                    imageUrls: []
                )
            )
            updatedWorkOrder.items[itemIndex].lastModified = Date()
            updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
            updatedWorkOrder.lastModified = Date()
            updatedWorkOrder.lastModifiedBy = appState.currentUserName
            
            try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
        } catch {
            print("❌ Error adding item note: \(error)")
        }
    }
    
    private func toggleReasonCompletion(_ reason: String) {
        Task {
            do {
                var updatedWorkOrder = workOrder
                if updatedWorkOrder.items[itemIndex].completedReasons.contains(reason) {
                    updatedWorkOrder.items[itemIndex].completedReasons.removeAll { $0 == reason }
                } else {
                    updatedWorkOrder.items[itemIndex].completedReasons.append(reason)
                }
                updatedWorkOrder.items[itemIndex].lastModified = Date()
                updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = appState.currentUserName
                
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
            } catch {
                print("❌ Error toggling reason completion: \(error)")
            }
        }
    }
}

// MARK: - FullItemDetailSheet
struct FullItemDetailSheet: View {
    let workOrder: WorkOrder
    let item: WO_Item
    let itemIndex: Int
    let onClose: () -> Void
    
    @EnvironmentObject private var appState: AppState
    @StateObject private var workOrdersDB = WorkOrdersDatabase.shared
    
    // ───── State for functionality ─────
    @State private var showStatusSelection = false
    @State private var showAddNotes = false
    @State private var showGallery = false
    @State private var showImageViewer = false
    @State private var selectedImageURL: URL?
    
    // ───── Computed Properties ─────
    private var itemDisplayName: String {
        "\(workOrder.workOrderNumber)-\(String(format: "%03d", itemIndex + 1))"
    }
    
    private var currentStatus: String {
        item.statusHistory.last?.status ?? "Checked In"
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // ───── Custom Navigation Header ─────
            HStack {
                Button("Back") {
                    onClose()
                }
                .foregroundColor(.blue)
                                    
                                    Spacer()
                                    
                Text("Item Details")
                    .font(.headline)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Menu {
                    Button("Change Status") {
                        showStatusSelection = true
                    }
                    
                    Button("Add Notes") {
                        showAddNotes = true
                    }
                    
                    Button("View Full Work Order") {
                        onClose()
                        appState.navigateToWorkOrderDetail(workOrder)
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                        .foregroundColor(.blue)
                }
            }
            .padding()
            .background(Color(.systemBackground))
            
            Divider()
            
            // ───── Content ─────
            ScrollView {
                VStack(spacing: 20) {
                    // ───── Item Header Card ─────
                    itemHeaderCard
                    
                    // ───── Item Images Section ─────
                    itemImagesSection
                    
                    // ───── Item Details Section ─────
                    itemDetailsSection
                    
                    // ───── Status & Notes Section ─────
                    statusAndNotesSection
                }
                .padding()
            }
        }
        .sheet(isPresented: $showStatusSelection) {
            StatusSelectionView(
                currentStatus: currentStatus,
                onStatusSelected: { newStatus in
                    Task {
                        await updateItemStatus(newStatus)
                    }
                    showStatusSelection = false
                }
            )
        }
        .sheet(isPresented: $showAddNotes) {
            AddNotesView(
                workOrder: workOrder,
                item: item,
                itemIndex: itemIndex,
                onNotesAdded: { noteText, images in
                    Task {
                        await addItemNote(noteText, images: images)
                    }
                    showAddNotes = false
                }
            )
        }
        .sheet(isPresented: $showGallery) {
            ImageGalleryView(images: item.imageUrls, title: itemDisplayName)
        }
        .sheet(isPresented: $showImageViewer) {
            if let imageURL = selectedImageURL {
                FullScreenImageViewer(imageURL: imageURL, isPresented: $showImageViewer)
            }
        }
    }
    
    // MARK: - View Components
    
    @ViewBuilder
    private var itemHeaderCard: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(itemDisplayName)
                    .font(.title2)
                    .fontWeight(.bold)
                
                Spacer()
                
                StatusBadge(status: currentStatus)
            }
            
            Text(item.type)
                .font(.title3)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
    
    @ViewBuilder
    private var itemImagesSection: some View {
        if !item.imageUrls.isEmpty {
            VStack(alignment: .leading, spacing: 12) {
                Text("Images")
                    .font(.headline)
                
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: 8) {
                    ForEach(Array(item.imageUrls.prefix(6).enumerated()), id: \.offset) { index, imageURL in
                        AsyncImage(url: URL(string: imageURL)) { image in
                            image
                                .resizable()
                                .scaledToFill()
                                .frame(height: 80)
                                .clipped()
                                .cornerRadius(8)
                                .onTapGesture {
                                    selectedImageURL = URL(string: imageURL)
                                    showImageViewer = true
                                }
                        } placeholder: {
                            Rectangle()
                                .fill(Color(.systemGray5))
                                .frame(height: 80)
                                .cornerRadius(8)
                        }
                    }
                }
                
                if item.imageUrls.count > 6 {
                    Button("View All Images") {
                        showGallery = true
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
    }
    
    @ViewBuilder
    private var itemDetailsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Item Details")
                .font(.headline)
            
            // ───── Customer Info ─────
            VStack(alignment: .leading, spacing: 8) {
                Text("Customer")
                    .font(.subheadline)
                    .fontWeight(.medium)
                
                Text(workOrder.customerName)
                    .font(.subheadline)
                
                if !workOrder.customerPhone.isEmpty {
                    HStack {
                        Text(workOrder.customerPhone)
                            .font(.subheadline)
                        
                        Spacer()
                        
                        Button(action: {
                            if let url = URL(string: "tel:\(workOrder.customerPhone)") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            Image(systemName: "phone")
                                .foregroundColor(.blue)
                        }
                    }
                }
            }
            
            // ───── Dropdown Details ─────
            if !item.dropdowns.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Specifications")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(Array(item.dropdowns.keys.sorted()), id: \.self) { key in
                        if let value = item.dropdowns[key], !value.isEmpty {
                            HStack {
                                Text("\(key):")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                Text(value)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                                Spacer()
                            }
                        }
                    }
                }
            }
            
            // ───── Reasons for Service ─────
            if !item.reasonsForService.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Reasons for Service")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(item.reasonsForService, id: \.self) { reason in
                        HStack(spacing: 8) {
                            Button(action: {
                                toggleReasonCompletion(reason)
                            }) {
                                Image(systemName: item.completedReasons.contains(reason) ? "checkmark.square.fill" : "square")
                                    .foregroundColor(item.completedReasons.contains(reason) ? .green : .secondary)
                            }
                            
                            // ───── Display reason with note for "Other" ─────
                            if reason.lowercased().contains("other") && !(item.reasonNotes?.isEmpty ?? true) {
                                Text("\(reason) • \(item.reasonNotes ?? "")")
                                    .font(.caption)
                                    .foregroundColor(.primary)
                            } else {
                                Text(reason)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                            }
                            
                            Spacer()
                        }
                    }
                }
                            }
                        }
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
    }
    
    @ViewBuilder
    private var statusAndNotesSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Status & Notes")
                .font(.headline)
            
            // ───── Status History ─────
            if !item.statusHistory.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Status History")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    ForEach(item.statusHistory.reversed(), id: \.timestamp) { status in
                        HStack {
                            VStack(alignment: .leading, spacing: 2) {
                                Text(status.status)
                                    .font(.caption)
                                    .fontWeight(.medium)
                                
                                Text("by \(status.user)")
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Text(status.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 2)
                    }
                }
                    }
                    
                    // ───── Notes ─────
                    if !item.notes.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Notes")
                        .font(.subheadline)
                        .fontWeight(.medium)
                            
                            ForEach(item.notes.reversed(), id: \.timestamp) { note in
                                VStack(alignment: .leading, spacing: 4) {
                            Text(note.text)
                                .font(.caption)
                                .foregroundColor(.primary)
                                    
                                    HStack {
                                        Text("by \(note.user)")
                                    .font(.caption2)
                                            .foregroundColor(.secondary)
                                        
                                        Spacer()
                                        
                                Text(note.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                    .font(.caption2)
                                            .foregroundColor(.secondary)
                                    }
                                }
                        .padding(.vertical, 2)
                    }
                }
                            }
                        }
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
                    }
    
    // MARK: - Actions
    
    private func updateItemStatus(_ newStatus: String) async {
        do {
            var updatedWorkOrder = workOrder
            updatedWorkOrder.items[itemIndex].statusHistory.append(
                WO_Status(
                    status: newStatus,
                    user: appState.currentUserName,
                    timestamp: Date(),
                    notes: nil
                )
            )
            updatedWorkOrder.items[itemIndex].lastModified = Date()
            updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
            updatedWorkOrder.lastModified = Date()
            updatedWorkOrder.lastModifiedBy = appState.currentUserName
            
            try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
        } catch {
            print("❌ Error updating item status: \(error)")
        }
    }
    
    private func addItemNote(_ noteText: String, images: [UIImage]) async {
        do {
            var updatedWorkOrder = workOrder
            updatedWorkOrder.items[itemIndex].notes.append(
                WO_Note(
                    workOrderId: workOrder.id,
                    itemId: item.id.uuidString,
                    user: appState.currentUserName,
                    text: noteText,
                    timestamp: Date(),
                    imageUrls: []
                )
            )
            updatedWorkOrder.items[itemIndex].lastModified = Date()
            updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
            updatedWorkOrder.lastModified = Date()
            updatedWorkOrder.lastModifiedBy = appState.currentUserName
            
            try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
        } catch {
            print("❌ Error adding item note: \(error)")
        }
    }
    
    private func toggleReasonCompletion(_ reason: String) {
        Task {
            do {
                var updatedWorkOrder = workOrder
                if updatedWorkOrder.items[itemIndex].completedReasons.contains(reason) {
                    updatedWorkOrder.items[itemIndex].completedReasons.removeAll { $0 == reason }
                } else {
                    updatedWorkOrder.items[itemIndex].completedReasons.append(reason)
                }
                updatedWorkOrder.items[itemIndex].lastModified = Date()
                updatedWorkOrder.items[itemIndex].lastModifiedBy = appState.currentUserName
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = appState.currentUserName
                
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
            } catch {
                print("❌ Error toggling reason completion: \(error)")
            }
        }
    }
}

// MARK: - ItemDetailSheetView
struct ItemDetailSheetView: View {
    let workOrder: WorkOrder
    let item: WO_Item
    let itemIndex: Int
    let onClose: () -> Void
    
    @EnvironmentObject var appState: AppState
    @StateObject private var workOrdersDB = WorkOrdersDatabase.shared
    
    // Simplified state management
    @State private var currentWorkOrder: WorkOrder
    @State private var currentItem: WO_Item
    @State private var isUpdating = false
    @State private var hasAppeared = false
    
    // UI state
    @State private var showImageViewer = false
    @State private var selectedImageURL: URL?
    @State private var showGallery = false
    @State private var showStatusSelection = false
    @State private var showAddNotes = false
    
    init(workOrder: WorkOrder, item: WO_Item, itemIndex: Int, onClose: @escaping () -> Void) {
        self.workOrder = workOrder
        self.item = item
        self.itemIndex = itemIndex
        self.onClose = onClose
        self._currentWorkOrder = State(initialValue: workOrder)
        self._currentItem = State(initialValue: item)
    }
    
    // Get the latest item data from the database
    private var latestItem: WO_Item {
        if let latestWorkOrder = workOrdersDB.workOrders.first(where: { $0.id == currentWorkOrder.id }),
           let foundItem = latestWorkOrder.items.first(where: { $0.id == currentItem.id }) {
            return foundItem
        }
        return currentItem
    }
    
    // Refresh data from database
    private func refreshData() {
        print("🔍 DEBUG: refreshData called")
        
        // Use the local workOrders array instead of fetching from Firebase
        if let latestWorkOrder = workOrdersDB.workOrders.first(where: { $0.id == workOrder.id }) {
            print("🔍 DEBUG: Found latest work order: \(latestWorkOrder.workOrderNumber)")
            
            // Only update if the data has actually changed to prevent infinite loops
            if currentWorkOrder.id != latestWorkOrder.id || currentWorkOrder.lastModified != latestWorkOrder.lastModified {
                currentWorkOrder = latestWorkOrder
                if itemIndex < latestWorkOrder.items.count {
                    let newItem = latestWorkOrder.items[itemIndex]
                    currentItem = newItem
                    print("🔍 DEBUG: Updated currentItem - status: \(newItem.statusHistory.last?.status ?? "none")")
                    print("🔍 DEBUG: Current item status history count: \(newItem.statusHistory.count)")
                    print("🔍 DEBUG: Current item notes count: \(newItem.notes.count)")
                }
            } else {
                print("🔍 DEBUG: No changes detected, skipping update")
            }
        } else {
            print("🔍 DEBUG: Could not find work order in local database")
        }
    }
    
    // MARK: - View Components
    
    private var headerRow: some View {
        HStack(alignment: .top, spacing: 12) {
            // Left: Composite WO_Number-ItemIndex (e.g., 250826-001-003)
            Text("\(currentWorkOrder.workOrderNumber)-\(String(format: "%03d", itemIndex + 1))")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(ThemeManager.shared.textPrimary)
                .lineLimit(1)
                .truncationMode(.tail)
            
            Spacer()
            
            // Middle: Reasons for Service (chosen at intake) — check to log "Service Performed — <Reason>"
            VStack(alignment: .leading, spacing: 6) {
                ForEach(latestItem.reasonsForService, id: \.self) { reason in
                    HStack(spacing: 8) {
                        Button(action: {
                            print("🔍 DEBUG: Reason button tapped for '\(reason)'")
                            print("🔍 DEBUG: isUpdating when reason button tapped: \(isUpdating)")
                            toggleReasonCompletion(reason)
                        }) {
                            Image(systemName: isReasonPerformed(reason) ? "checkmark.square.fill" : "square")
                                .foregroundColor(isReasonPerformed(reason) ? .green : ThemeManager.shared.textSecondary)
                        }
                        .disabled(isUpdating)
                        .onTapGesture {
                            print("🔍 DEBUG: Reason button onTapGesture triggered for '\(reason)'")
                        }
                        
                        // ───── Display reason with note for "Other" ─────
                        if reason.lowercased().contains("other") && !(latestItem.reasonNotes?.isEmpty ?? true) {
                            Text("\(reason) • \(latestItem.reasonNotes ?? "")")
                                .font(.subheadline)
                                .foregroundColor(ThemeManager.shared.textPrimary)
                                .lineLimit(1)
                                .minimumScaleFactor(0.9)
                        } else {
                            Text(reason)
                                .font(.subheadline)
                                .foregroundColor(ThemeManager.shared.textPrimary)
                                .lineLimit(1)
                                .minimumScaleFactor(0.9)
                        }
                    }
                }
            }
            
            // Right: StatusBadge (tappable) and Add Notes button
            VStack(spacing: 8) {
                Button(action: {
                    print("🔍 DEBUG: Status button tapped - setting showStatusSelection to true")
                    print("🔍 DEBUG: isUpdating when status button tapped: \(isUpdating)")
                    showStatusSelection = true
                    print("🔍 DEBUG: showStatusSelection is now: \(showStatusSelection)")
                }) {
                    StatusBadge(status: getActualItemStatus(latestItem))
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(isUpdating)
                .onTapGesture {
                    print("🔍 DEBUG: Status button onTapGesture triggered")
                }
                .overlay(
                    isUpdating ? 
                    ProgressView()
                        .scaleEffect(0.8)
                        .background(Color.white.opacity(0.8))
                        .cornerRadius(8)
                    : nil
                )
                
                Button(action: {
                    print("🔍 DEBUG: Add Notes button tapped")
                    print("🔍 DEBUG: isUpdating: \(isUpdating)")
                    print("🔍 DEBUG: showAddNotes before: \(showAddNotes)")
                    showAddNotes = true
                    print("🔍 DEBUG: showAddNotes after: \(showAddNotes)")
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "note.text.badge.plus")
                            .foregroundColor(ThemeManager.shared.linkColor)
                            .font(.title3)
                        Text("Add Note")
                            .font(.caption)
                            .foregroundColor(ThemeManager.shared.linkColor)
                    }
                    .frame(width: 60, height: 50)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
                }
                .disabled(isUpdating)
                .buttonStyle(PlainButtonStyle())
                .onTapGesture {
                    print("🔍 DEBUG: Add Notes button onTapGesture triggered")
                }
            }
        }
    }
    
    private var itemDetails: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Type line
            Text(latestItem.type.isEmpty ? "Item" : latestItem.type)
                .font(.subheadline)
                .foregroundColor(ThemeManager.shared.textSecondary)
                .lineLimit(1)
                .truncationMode(.tail)
            
            // Size / Color / Machine / Brand / Wait summary (muted), with inline "Other" note if present
            if !summaryLineForItem(latestItem).isEmpty {
                Text(summaryLineForItem(latestItem))
                    .font(.caption)
                    .foregroundColor(ThemeManager.shared.textSecondary)
                    .lineLimit(1)
                    .truncationMode(.tail)
            }
        }
    }
    
    private var mainBody: some View {
        HStack(alignment: .top, spacing: 16) {
            // Left: Primary image (large, 1:1) + responsive 2×2 thumbnails beneath
            VStack(spacing: 8) {
                // Use a fixed size that allows cards to expand
                let primarySize: CGFloat = 300
                let gridSpacing: CGFloat = 8
                let thumbSize = (primarySize - gridSpacing) / 2.0
                
                VStack(spacing: 8) {
                    // PRIMARY 1:1 image
                    if let firstImageURL = latestItem.imageUrls.first {
                        AsyncImage(url: URL(string: firstImageURL)) { image in
                            image
                                .resizable()
                                .scaledToFill() // crop, do not stretch
                                .frame(width: primarySize, height: primarySize)
                                .clipped()
                                .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                                .onTapGesture { 
                                    selectedImageURL = URL(string: firstImageURL)
                                    showImageViewer = true
                                }
                        } placeholder: {
                            Rectangle()
                                .fill(ThemeManager.shared.border.opacity(0.3))
                                .frame(width: primarySize, height: primarySize)
                                .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                        }
                    } else {
                        Rectangle()
                            .fill(ThemeManager.shared.border.opacity(0.3))
                            .frame(width: primarySize, height: primarySize)
                            .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                    }
                    
                    // 2×2 THUMBNAIL GRID
                    if latestItem.imageUrls.count > 1 {
                        LazyVGrid(columns: Array(repeating: GridItem(.fixed(thumbSize), spacing: gridSpacing), count: 2), spacing: gridSpacing) {
                            ForEach(Array(latestItem.imageUrls.dropFirst().enumerated()), id: \.offset) { index, imageURL in
                                AsyncImage(url: URL(string: imageURL)) { img in
                                    img.resizable()
                                        .scaledToFill()
                                        .frame(width: thumbSize, height: thumbSize)
                                        .clipped()
                                        .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                        .onTapGesture { 
                                            print("🔍 DEBUG: Image tapped: \(imageURL)")
                                            selectedImageURL = URL(string: imageURL)
                                            print("🔍 DEBUG: selectedImageURL set to: \(selectedImageURL?.absoluteString ?? "nil")")
                                            showImageViewer = true
                                            print("🔍 DEBUG: showImageViewer set to: \(showImageViewer)")
                                        }
                                } placeholder: {
                                    Rectangle()
                                        .fill(ThemeManager.shared.border.opacity(0.3))
                                        .frame(width: thumbSize, height: thumbSize)
                                        .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                }
                            }
                        }
                    }
                }
            }
            
            // Right: Notes & Status
            VStack(alignment: .leading, spacing: 12) {
                // ───── Notes ─────
                if !latestItem.notes.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Notes")
                            .font(.subheadline)
                            .fontWeight(.medium)
                        
                        ForEach(latestItem.notes.reversed(), id: \.timestamp) { note in
                            VStack(alignment: .leading, spacing: 4) {
                                Text(note.text)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                                
                                HStack {
                                    Text("by \(note.user)")
                                        .font(.caption2)
                                        .foregroundColor(.secondary)
                                    
                                    Spacer()
                                    
                                    Text(note.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                        .font(.caption2)
                                        .foregroundColor(.secondary)
                                }
                            }
                            .padding(.vertical, 2)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
            }
        }
    }
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 12) {
                    // Header row: Composite item number • Reasons (checkboxes) • StatusBadge
                    headerRow
                    
                    // Item details
                    itemDetails
                    
                    // Main body split: Left (images) + Right (notes & status)
                    mainBody
                            
                            VStack(spacing: 8) {
                                // PRIMARY 1:1 image
                                if let firstImageURL = latestItem.imageUrls.first {
                                    AsyncImage(url: URL(string: firstImageURL)) { image in
                                        image
                                            .resizable()
                                            .scaledToFill() // crop, do not stretch
                                            .frame(width: primarySize, height: primarySize)
                                            .clipped()
                                            .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                                            .onTapGesture { 
                                                selectedImageURL = URL(string: firstImageURL)
                                                showImageViewer = true
                                            }
                                    } placeholder: {
                                        Rectangle()
                                            .fill(ThemeManager.shared.border.opacity(0.3))
                                            .frame(width: primarySize, height: primarySize)
                                            .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                                    }
                } else {
                                    // No images: placeholder primary
                                    Rectangle()
                                        .fill(ThemeManager.shared.border.opacity(0.2))
                                        .frame(width: primarySize, height: primarySize)
                                        .cornerRadius(ThemeManager.shared.cardCornerRadius - 2)
                                        .overlay(
                                            Image(systemName: "photo")
                                                .font(.system(size: primarySize * 0.12, weight: .regular))
                                                .foregroundColor(ThemeManager.shared.textSecondary)
                                        )
                                }
                                
                                // 2×2 thumbnails directly beneath primary (images 2,3,4, +Qty)
                                if latestItem.imageUrls.count > 1 {
                                    let extras = Array(latestItem.imageUrls.dropFirst())
                                    LazyVGrid(
                                        columns: [
                                            GridItem(.fixed(thumbSize), spacing: gridSpacing),
                                            GridItem(.fixed(thumbSize), spacing: gridSpacing)
                                        ],
                                        spacing: gridSpacing
                                    ) {
                                        ForEach(Array(extras.prefix(3).enumerated()), id: \.offset) { _, imageURL in
                                            AsyncImage(url: URL(string: imageURL)) { img in
                                                img.resizable()
                                                    .scaledToFill()
                                                    .frame(width: thumbSize, height: thumbSize)
                                                    .clipped()
                                                    .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                                    .onTapGesture { 
                                                        print("🔍 DEBUG: Image tapped: \(imageURL)")
                                                        selectedImageURL = URL(string: imageURL)
                                                        print("🔍 DEBUG: selectedImageURL set to: \(selectedImageURL?.absoluteString ?? "nil")")
                                                        showImageViewer = true
                                                        print("🔍 DEBUG: showImageViewer set to: \(showImageViewer)")
                                                    }
                                            } placeholder: {
                                                Rectangle()
                                                    .fill(ThemeManager.shared.border.opacity(0.3))
                                                    .frame(width: thumbSize, height: thumbSize)
                                                    .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                            }
                                        }
                                        
                                        // +Qty tile if there are 6 or more total images
                                        if latestItem.imageUrls.count >= 6 {
                                            Button(action: {
                                                // Show gallery for all images
                                                showGallery = true
                                            }) {
                                                ZStack {
                                                    // Show the 5th image (index 4) as background
                                                    AsyncImage(url: URL(string: latestItem.imageUrls[4])) { image in
                                                        image
                                                            .resizable()
                                                            .aspectRatio(contentMode: .fill)
                                                            .frame(width: thumbSize, height: thumbSize)
                                                            .clipped()
                                                            .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                                    } placeholder: {
                                                        Rectangle()
                                                            .fill(ThemeManager.shared.border.opacity(0.3))
                                                            .frame(width: thumbSize, height: thumbSize)
                                                            .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                                    }
                                                    
                                                    // Dark overlay
                                                    Rectangle()
                                                        .fill(Color.black.opacity(0.6))
                                                        .frame(width: thumbSize, height: thumbSize)
                                                        .cornerRadius(ThemeManager.shared.cardCornerRadius - 6)
                                                    
                                                    // +Qty text
                                                    Text("+\(latestItem.imageUrls.count - 4)")
                                                        .font(.headline)
                                                        .foregroundColor(.white)
                                                }
                                            }
                                            .buttonStyle(PlainButtonStyle())
                                        }
                                    }
                                    .frame(width: primarySize, alignment: .leading) // grid width matches primary
                                }
                            }
                        }
                        
                        // Right: Notes & Status timeline
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Notes & Status")
                        .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(ThemeManager.shared.textPrimary)
                            
                            // Unified timeline: notes and status history chronologically
                            LazyVStack(alignment: .leading, spacing: 4) {
                                ForEach(getCombinedTimeline(), id: \.id) { timelineItem in
                                    HStack(alignment: .top, spacing: 8) {
                                        Text("•")
                                            .foregroundColor(ThemeManager.shared.textSecondary)
                                        
                                        VStack(alignment: .leading, spacing: 2) {
                                            timelineItem.content
                                            
                                            HStack {
                                                Text(timelineItem.user)
                                                    .font(.system(size: 10 * 1.2))
                                                    .foregroundColor(ThemeManager.shared.textSecondary)
                                                
                                                Text("•")
                                                    .font(.system(size: 10 * 1.2))
                                                    .foregroundColor(ThemeManager.shared.textSecondary)
                                                
                                                Text(timelineItem.timestamp, format: .dateTime.month(.abbreviated).day().year().hour().minute())
                                                    .font(.system(size: 10 * 1.2))
                                                    .foregroundColor(ThemeManager.shared.textSecondary)
                                            }
                                            
                                            Spacer()
                                        }
                                        
                                        Spacer()
                                    }
                                }
                            }
                        }
                        
                        Spacer()
                    }
                }
                .padding(16)
                .background(ThemeManager.shared.cardBackground)
                .cornerRadius(ThemeManager.shared.cardCornerRadius)
                .shadow(
                    color: ThemeManager.shared.cardShadowColor.opacity(ThemeManager.shared.cardShadowOpacity),
                    radius: 8,
                    x: 0,
                    y: 4
                )
            }
            .navigationTitle("Item Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Close") {
                        print("🔍 DEBUG: Close button tapped")
                        onClose()
                    }
                }
            }
        }
        .trackUserInteraction() // Track user interactions to prevent inactivity logout
        .onAppear {
            print("🔍 DEBUG: ItemDetailSheetView onAppear")
            isUpdating = false // Reset updating state
            print("🔍 DEBUG: isUpdating reset to false on appear")
            
            // Prevent infinite loops by only refreshing on first appear
            if !hasAppeared {
                hasAppeared = true
                refreshData()
            }
        }
        .onDisappear {
            print("🔍 DEBUG: ItemDetailSheetView onDisappear")
            isUpdating = false // Reset updating state
            hasAppeared = false // Reset appear flag
            print("🔍 DEBUG: isUpdating reset to false on disappear")
        }
        .fullScreenCover(isPresented: $showGallery) {
            ImageGalleryView(images: latestItem.imageUrls, title: "\(currentWorkOrder.workOrderNumber)-\(String(format: "%03d", itemIndex + 1))")
        }
        .fullScreenCover(isPresented: $showStatusSelection) {
            StatusSelectionView(
                currentStatus: latestItem.statusHistory.last?.status ?? "Checked In",
                onStatusSelected: { newStatus in
                    print("🔍 DEBUG: ItemDetailSheetView - Status selected: \(newStatus)")
                    updateItemStatus(newStatus)
                    showStatusSelection = false
                    print("🔍 DEBUG: ItemDetailSheetView - Status selection sheet dismissed")
                }
            )
        }
        .fullScreenCover(isPresented: $showAddNotes) {
            SimpleAddNotesView(
                onNotesAdded: { noteText, images in
                    addItemNote(noteText, images: images)
                    showAddNotes = false
                    // Force refresh to show the new note immediately
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        refreshData()
                    }
                }
            )
            .onDisappear {
                print("🔍 DEBUG: Add Notes sheet dismissed, refreshing data")
                refreshData()
            }
        }
        .fullScreenCover(isPresented: $showImageViewer) {
            if let imageURL = selectedImageURL {
                print("🔍 DEBUG: FullScreenImageViewer showing image: \(imageURL)")
                FullScreenImageViewer(imageURL: imageURL, isPresented: $showImageViewer)
                    .onDisappear {
                        print("🔍 DEBUG: FullScreenImageViewer dismissed")
                        selectedImageURL = nil
                    }
            } else {
                print("🔍 DEBUG: FullScreenImageViewer - selectedImageURL is nil")
                VStack {
                    Text("No image selected")
                        .foregroundColor(.white)
                        .font(.headline)
                    Button("Close") {
                        showImageViewer = false
                    }
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(8)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black.opacity(0.8))
            }
        }
    }
    
    // MARK: - Helper Functions
    func isReasonPerformed(_ reason: String) -> Bool {
        return latestItem.completedReasons.contains(reason)
    }
    
    func getActualItemStatus(_ item: WO_Item) -> String {
        // Return the most recent status from statusHistory
        return item.statusHistory.last?.status ?? "Checked In"
    }
    
    func summaryLineForItem(_ item: WO_Item) -> String {
        var components: [String] = []
        
        if let size = item.dropdowns["Size"], !size.isEmpty {
            components.append("Size: \(size)")
        }
        if let color = item.dropdowns["Color"], !color.isEmpty {
            components.append("Color: \(color)")
        }
        if let machine = item.dropdowns["Machine"], !machine.isEmpty {
            components.append("Machine: \(machine)")
        }
        if let brand = item.dropdowns["Brand"], !brand.isEmpty {
            components.append("Brand: \(brand)")
        }
        
        return components.joined(separator: " • ")
    }
    
    
    // MARK: - Timeline Item Structure
    struct TimelineItem: Identifiable {
        let id: UUID
        let timestamp: Date
        let user: String
        let content: AnyView
        let type: TimelineItemType
        
        enum TimelineItemType {
            case note
            case status
        }
    }
    
    func getCombinedTimeline() -> [TimelineItem] {
        var timelineItems: [TimelineItem] = []
        
        // Add notes
        for note in latestItem.notes {
            timelineItems.append(TimelineItem(
                id: note.id,
                timestamp: note.timestamp,
                user: note.user,
                content: AnyView(
                    VStack(alignment: .leading, spacing: 2) {
                        Text(note.text)
                            .font(.system(size: 12 * 1.2))
                            .foregroundColor(ThemeManager.shared.textPrimary)
                        
                        if !note.imageUrls.isEmpty {
                            Text("\(note.imageUrls.count) image\(note.imageUrls.count == 1 ? "" : "s") attached")
                                .font(.system(size: 10 * 1.2))
                                .foregroundColor(ThemeManager.shared.textSecondary)
                        }
                    }
                ),
                type: .note
            ))
        }
        
        // Add status history
        for status in latestItem.statusHistory {
            timelineItems.append(TimelineItem(
                id: UUID(),
                timestamp: status.timestamp,
                user: status.user,
                content: AnyView(
                    Text("Status changed to: \(status.status)")
                        .font(.system(size: 12 * 1.2, weight: .medium))
                        .foregroundColor(ThemeManager.shared.textPrimary)
                ),
                type: .status
            ))
        }
        
        // Sort by timestamp (newest first)
        return timelineItems.sorted { $0.timestamp > $1.timestamp }
    }
    
    // MARK: - Actions
    private func updateItemStatus(_ newStatus: String) {
        print("🔍 DEBUG: updateItemStatus called with status: \(newStatus)")
        guard !isUpdating else { 
            print("🔍 DEBUG: updateItemStatus blocked - already updating")
            return 
        }
        
        print("🔍 DEBUG: updateItemStatus proceeding with update")
        // Track user interaction to reset inactivity timer
        InactivityManager.trackUserInteraction()
        
        Task {
            await MainActor.run { 
                isUpdating = true
            }
            
            do {
                // Fetch the latest work order from the database
                let latestWorkOrder = try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<WorkOrder, Error>) in
                    workOrdersDB.fetchWorkOrder(woId: workOrder.id) { result in
                        switch result {
                        case .success(let workOrder):
                            continuation.resume(returning: workOrder)
                        case .failure(let error):
                            continuation.resume(throwing: error)
                        }
                    }
                }
                var updatedWorkOrder = latestWorkOrder
                
                let status = WO_Status(
                    status: newStatus,
                    user: appState.currentUserName,
                    timestamp: Date()
                )
                
                updatedWorkOrder.items[itemIndex].statusHistory.append(status)
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = appState.currentUserName
                
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
                
                // Add a small delay to ensure the database update is reflected
                try await Task.sleep(nanoseconds: 50_000_000) // 0.05 seconds
                
                // Refresh data after successful update
                await MainActor.run {
                    refreshData()
                }
            } catch {
                print("❌ Error updating item status: \(error)")
            }
            
            await MainActor.run {
                isUpdating = false
                print("🔍 DEBUG: isUpdating reset to false")
            }
        }
    }
    
    private func addItemNote(_ noteText: String, images: [UIImage]) {
        guard !isUpdating else { return }
        
        // Track user interaction to reset inactivity timer
        InactivityManager.trackUserInteraction()
        
        Task {
            await MainActor.run { 
                isUpdating = true
            }
            
            do {
                // Fetch the latest work order from the database
                let latestWorkOrder = try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<WorkOrder, Error>) in
                    workOrdersDB.fetchWorkOrder(woId: workOrder.id) { result in
                        switch result {
                        case .success(let workOrder):
                            continuation.resume(returning: workOrder)
                        case .failure(let error):
                            continuation.resume(throwing: error)
                        }
                    }
                }
                var updatedWorkOrder = latestWorkOrder
                
                let note = WO_Note(
                    workOrderId: workOrder.id,
                    itemId: item.id.uuidString,
                    user: appState.currentUserName,
                    text: noteText,
                    timestamp: Date(),
                    imageUrls: [] // Images will be uploaded separately
                )
                
                updatedWorkOrder.items[itemIndex].notes.append(note)
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = appState.currentUserName
                
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
                
                // Add a small delay to ensure the database update is reflected
                try await Task.sleep(nanoseconds: 50_000_000) // 0.05 seconds
                
                // Refresh data after successful update
                await MainActor.run {
                    refreshData()
                }
            } catch {
                print("❌ Error adding item note: \(error)")
            }
            
            await MainActor.run {
                isUpdating = false
                print("🔍 DEBUG: isUpdating reset to false")
            }
        }
    }
    
    private func toggleReasonCompletion(_ reason: String) {
        guard !isUpdating else { return }
        
        // Track user interaction to reset inactivity timer
        InactivityManager.trackUserInteraction()
        
        Task {
            await MainActor.run { 
                isUpdating = true
            }
            
            do {
                // Fetch the latest work order from the database
                let latestWorkOrder = try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<WorkOrder, Error>) in
                    workOrdersDB.fetchWorkOrder(woId: workOrder.id) { result in
                        switch result {
                        case .success(let workOrder):
                            continuation.resume(returning: workOrder)
                        case .failure(let error):
                            continuation.resume(throwing: error)
                        }
                    }
                }
                var updatedWorkOrder = latestWorkOrder
                
                if updatedWorkOrder.items[itemIndex].completedReasons.contains(reason) {
                    updatedWorkOrder.items[itemIndex].completedReasons.removeAll { $0 == reason }
                } else {
                    updatedWorkOrder.items[itemIndex].completedReasons.append(reason)
                }
                
                updatedWorkOrder.lastModified = Date()
                updatedWorkOrder.lastModifiedBy = appState.currentUserName
                
                try await workOrdersDB.updateWorkOrder(updatedWorkOrder)
                
                // Add a small delay to ensure the database update is reflected
                try await Task.sleep(nanoseconds: 50_000_000) // 0.05 seconds
                
                // Refresh data after successful update
                await MainActor.run {
                    refreshData()
                }
            } catch {
                print("❌ Error toggling reason completion: \(error)")
            }
            
            await MainActor.run {
                isUpdating = false
                print("🔍 DEBUG: isUpdating reset to false")
            }
        }
    }
}

// MARK: - SimpleAddNotesView
struct SimpleAddNotesView: View {
    let onNotesAdded: (String, [UIImage]) -> Void
    @Environment(\.dismiss) private var dismiss
    
    @State private var noteText = ""
    @State private var selectedImages: [UIImage] = []
    @State private var showingImagePicker = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                TextField("Enter note...", text: $noteText, axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
                
                if !selectedImages.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 10) {
                            ForEach(Array(selectedImages.enumerated()), id: \.offset) { index, image in
                                Image(uiImage: image)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 100, height: 100)
                                    .clipped()
                                    .cornerRadius(8)
                                    .overlay(
                                        Button(action: {
                                            selectedImages.remove(at: index)
                                        }) {
                                            Image(systemName: "xmark.circle.fill")
                                                .foregroundColor(.red)
                                                .background(Color.white)
                                                .clipShape(Circle())
                                        }
                                        .padding(4),
                                        alignment: .topTrailing
                                    )
                            }
                        }
                        .padding(.horizontal)
                    }
                }
                
                Button("Add Images") {
                    showingImagePicker = true
                }
                .buttonStyle(.bordered)
                
                Spacer()
            }
            .padding()
            .navigationTitle("Add Note")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        onNotesAdded(noteText, selectedImages)
                    }
                    .disabled(noteText.isEmpty && selectedImages.isEmpty)
                }
            }
        }
        .sheet(isPresented: $showingImagePicker) {
            SimpleImagePicker(selectedImages: $selectedImages)
        }
    }
}

// MARK: - SimpleImagePicker
struct SimpleImagePicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.dismiss) private var dismiss
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .photoLibrary
        picker.allowsEditing = false
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: SimpleImagePicker
        
        init(_ parent: SimpleImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.selectedImages.append(image)
            }
            parent.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.dismiss()
        }
    }
}



// ───── PREVIEW ─────
#Preview {
    let appState = AppState.previewLoggedIn(role: .tech)
    MyWorkOrderItemsView()
        .environmentObject(appState)
}
// END